# coding: utf-8

"""
    \"Agent Toolkit: LLM-Friendly Tools and Search APIs\"

    API for LLM-friendly web search and content retrieval

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError

from typing_extensions import Annotated
from datetime import date

from pydantic import Field, StrictBool, StrictStr, conint, conlist

from typing import Any, Dict, List, Optional

from at_client.models.api_key_create import ApiKeyCreate
from at_client.models.api_key_info import ApiKeyInfo
from at_client.models.api_key_response import ApiKeyResponse
from at_client.models.api_key_status import ApiKeyStatus
from at_client.models.extract_request import ExtractRequest
from at_client.models.extract_response import ExtractResponse
from at_client.models.search_response import SearchResponse

from at_client.api_client import ApiClient
from at_client.api_response import ApiResponse
from at_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class DefaultApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def auth_google_options_api_v1_auth_google_options(self, **kwargs) -> object:  # noqa: E501
        """Auth Google Options  # noqa: E501

        Handle preflight OPTIONS request for Google auth endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.auth_google_options_api_v1_auth_google_options(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the auth_google_options_api_v1_auth_google_options_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.auth_google_options_api_v1_auth_google_options_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def auth_google_options_api_v1_auth_google_options_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """Auth Google Options  # noqa: E501

        Handle preflight OPTIONS request for Google auth endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.auth_google_options_api_v1_auth_google_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method auth_google_options_api_v1_auth_google_options" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '500': "AppModelsCoreErrorResponse",
        }

        return self.api_client.call_api(
            '/api/v1/auth/google', 'OPTIONS',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def auth_logout_options_api_v1_auth_logout_options(self, **kwargs) -> object:  # noqa: E501
        """Auth Logout Options  # noqa: E501

        Handle preflight OPTIONS request for auth/logout endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.auth_logout_options_api_v1_auth_logout_options(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the auth_logout_options_api_v1_auth_logout_options_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.auth_logout_options_api_v1_auth_logout_options_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def auth_logout_options_api_v1_auth_logout_options_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """Auth Logout Options  # noqa: E501

        Handle preflight OPTIONS request for auth/logout endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.auth_logout_options_api_v1_auth_logout_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method auth_logout_options_api_v1_auth_logout_options" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '500': "AppModelsCoreErrorResponse",
        }

        return self.api_client.call_api(
            '/api/v1/auth/logout', 'OPTIONS',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def auth_me_options_api_v1_auth_me_options(self, **kwargs) -> object:  # noqa: E501
        """Auth Me Options  # noqa: E501

        Handle preflight OPTIONS request for auth/me endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.auth_me_options_api_v1_auth_me_options(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the auth_me_options_api_v1_auth_me_options_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.auth_me_options_api_v1_auth_me_options_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def auth_me_options_api_v1_auth_me_options_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """Auth Me Options  # noqa: E501

        Handle preflight OPTIONS request for auth/me endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.auth_me_options_api_v1_auth_me_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method auth_me_options_api_v1_auth_me_options" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '500': "AppModelsCoreErrorResponse",
        }

        return self.api_client.call_api(
            '/api/v1/auth/me', 'OPTIONS',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def create_api_key_endpoint_api_v1_api_keys_post(self, api_key_create : ApiKeyCreate, auth_token : Optional[StrictStr] = None, **kwargs) -> ApiKeyResponse:  # noqa: E501
        """Create Api Key Endpoint  # noqa: E501

        Create a new API key for the authenticated user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_api_key_endpoint_api_v1_api_keys_post(api_key_create, auth_token, async_req=True)
        >>> result = thread.get()

        :param api_key_create: (required)
        :type api_key_create: ApiKeyCreate
        :param auth_token:
        :type auth_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiKeyResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the create_api_key_endpoint_api_v1_api_keys_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.create_api_key_endpoint_api_v1_api_keys_post_with_http_info(api_key_create, auth_token, **kwargs)  # noqa: E501

    @validate_arguments
    def create_api_key_endpoint_api_v1_api_keys_post_with_http_info(self, api_key_create : ApiKeyCreate, auth_token : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create Api Key Endpoint  # noqa: E501

        Create a new API key for the authenticated user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_api_key_endpoint_api_v1_api_keys_post_with_http_info(api_key_create, auth_token, async_req=True)
        >>> result = thread.get()

        :param api_key_create: (required)
        :type api_key_create: ApiKeyCreate
        :param auth_token:
        :type auth_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiKeyResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_key_create',
            'auth_token'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_api_key_endpoint_api_v1_api_keys_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_key_create'] is not None:
            _body_params = _params['api_key_create']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['OAuth2PasswordBearer']  # noqa: E501

        _response_types_map = {
            '200': "ApiKeyResponse",
            '500': "AppModelsCoreErrorResponse",
            '422': "HTTPValidationError",
        }

        return self.api_client.call_api(
            '/api/v1/api-keys', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def extract_content_api_v1_extract_post(self, extract_request : ExtractRequest, **kwargs) -> ExtractResponse:  # noqa: E501
        """Extract Content  # noqa: E501

        Extract content from one or more URLs using Selenium.  Args:     request: ExtractRequest object with URLs and extraction options      Returns:     ExtractResponse with extraction results and metadata  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.extract_content_api_v1_extract_post(extract_request, async_req=True)
        >>> result = thread.get()

        :param extract_request: (required)
        :type extract_request: ExtractRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExtractResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the extract_content_api_v1_extract_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.extract_content_api_v1_extract_post_with_http_info(extract_request, **kwargs)  # noqa: E501

    @validate_arguments
    def extract_content_api_v1_extract_post_with_http_info(self, extract_request : ExtractRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """Extract Content  # noqa: E501

        Extract content from one or more URLs using Selenium.  Args:     request: ExtractRequest object with URLs and extraction options      Returns:     ExtractResponse with extraction results and metadata  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.extract_content_api_v1_extract_post_with_http_info(extract_request, async_req=True)
        >>> result = thread.get()

        :param extract_request: (required)
        :type extract_request: ExtractRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExtractResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'extract_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method extract_content_api_v1_extract_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['extract_request'] is not None:
            _body_params = _params['extract_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ExtractResponse",
            '500': "AppModelsCoreErrorResponse",
            '422': "HTTPValidationError",
        }

        return self.api_client.call_api(
            '/api/v1/extract', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def extract_content_get_api_v1_extract_get(self, url : Annotated[StrictStr, Field(..., description="URL to extract content from")], include_images : Annotated[Optional[StrictBool], Field(description="Include images in the response")] = None, include_links : Annotated[Optional[StrictBool], Field(description="Include internal links found on the page in the response")] = None, extract_depth : Annotated[Optional[StrictStr], Field(description="Depth of extraction ('basic' or 'advanced')")] = None, **kwargs) -> ExtractResponse:  # noqa: E501
        """Extract Content Get  # noqa: E501

        Extract content from a URL using Selenium (GET method).  Args:     url: URL to extract content from     include_images: Whether to include images in the result     include_links: Whether to include internal links in the result     extract_depth: Depth of extraction (\"basic\" or \"advanced\")  Returns:     ExtractResponse with extraction results and metadata  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.extract_content_get_api_v1_extract_get(url, include_images, include_links, extract_depth, async_req=True)
        >>> result = thread.get()

        :param url: URL to extract content from (required)
        :type url: str
        :param include_images: Include images in the response
        :type include_images: bool
        :param include_links: Include internal links found on the page in the response
        :type include_links: bool
        :param extract_depth: Depth of extraction ('basic' or 'advanced')
        :type extract_depth: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExtractResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the extract_content_get_api_v1_extract_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.extract_content_get_api_v1_extract_get_with_http_info(url, include_images, include_links, extract_depth, **kwargs)  # noqa: E501

    @validate_arguments
    def extract_content_get_api_v1_extract_get_with_http_info(self, url : Annotated[StrictStr, Field(..., description="URL to extract content from")], include_images : Annotated[Optional[StrictBool], Field(description="Include images in the response")] = None, include_links : Annotated[Optional[StrictBool], Field(description="Include internal links found on the page in the response")] = None, extract_depth : Annotated[Optional[StrictStr], Field(description="Depth of extraction ('basic' or 'advanced')")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Extract Content Get  # noqa: E501

        Extract content from a URL using Selenium (GET method).  Args:     url: URL to extract content from     include_images: Whether to include images in the result     include_links: Whether to include internal links in the result     extract_depth: Depth of extraction (\"basic\" or \"advanced\")  Returns:     ExtractResponse with extraction results and metadata  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.extract_content_get_api_v1_extract_get_with_http_info(url, include_images, include_links, extract_depth, async_req=True)
        >>> result = thread.get()

        :param url: URL to extract content from (required)
        :type url: str
        :param include_images: Include images in the response
        :type include_images: bool
        :param include_links: Include internal links found on the page in the response
        :type include_links: bool
        :param extract_depth: Depth of extraction ('basic' or 'advanced')
        :type extract_depth: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExtractResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'url',
            'include_images',
            'include_links',
            'extract_depth'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method extract_content_get_api_v1_extract_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('url') is not None:  # noqa: E501
            _query_params.append(('url', _params['url']))

        if _params.get('include_images') is not None:  # noqa: E501
            _query_params.append(('include_images', _params['include_images']))

        if _params.get('include_links') is not None:  # noqa: E501
            _query_params.append(('include_links', _params['include_links']))

        if _params.get('extract_depth') is not None:  # noqa: E501
            _query_params.append(('extract_depth', _params['extract_depth']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ExtractResponse",
            '500': "AppModelsCoreErrorResponse",
            '422': "HTTPValidationError",
        }

        return self.api_client.call_api(
            '/api/v1/extract', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_current_user_info_api_v1_auth_me_get(self, auth_token : Optional[StrictStr] = None, **kwargs) -> Dict[str, object]:  # noqa: E501
        """Get Current User Info  # noqa: E501

        Get current user information from cookie authentication  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_current_user_info_api_v1_auth_me_get(auth_token, async_req=True)
        >>> result = thread.get()

        :param auth_token:
        :type auth_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Dict[str, object]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_current_user_info_api_v1_auth_me_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_current_user_info_api_v1_auth_me_get_with_http_info(auth_token, **kwargs)  # noqa: E501

    @validate_arguments
    def get_current_user_info_api_v1_auth_me_get_with_http_info(self, auth_token : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Current User Info  # noqa: E501

        Get current user information from cookie authentication  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_current_user_info_api_v1_auth_me_get_with_http_info(auth_token, async_req=True)
        >>> result = thread.get()

        :param auth_token:
        :type auth_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Dict[str, object], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'auth_token'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_current_user_info_api_v1_auth_me_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['OAuth2PasswordBearer']  # noqa: E501

        _response_types_map = {
            '200': "Dict[str, object]",
            '500': "AppModelsCoreErrorResponse",
            '422': "HTTPValidationError",
        }

        return self.api_client.call_api(
            '/api/v1/auth/me', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_providers_api_v1_providers_get(self, auth_token : Optional[StrictStr] = None, **kwargs) -> List[Dict[str, object]]:  # noqa: E501
        """Get Providers  # noqa: E501

        Return a list of available search providers and their capabilities.  This endpoint returns information about all search providers supported by the API, including their capabilities, requirements, and other metadata.  Returns:     List of provider objects with details about each provider  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_providers_api_v1_providers_get(auth_token, async_req=True)
        >>> result = thread.get()

        :param auth_token:
        :type auth_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Dict[str, object]]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_providers_api_v1_providers_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_providers_api_v1_providers_get_with_http_info(auth_token, **kwargs)  # noqa: E501

    @validate_arguments
    def get_providers_api_v1_providers_get_with_http_info(self, auth_token : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Providers  # noqa: E501

        Return a list of available search providers and their capabilities.  This endpoint returns information about all search providers supported by the API, including their capabilities, requirements, and other metadata.  Returns:     List of provider objects with details about each provider  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_providers_api_v1_providers_get_with_http_info(auth_token, async_req=True)
        >>> result = thread.get()

        :param auth_token:
        :type auth_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Dict[str, object]], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'auth_token'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_providers_api_v1_providers_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['OAuth2PasswordBearer']  # noqa: E501

        _response_types_map = {
            '200': "List[Dict[str, object]]",
            '500': "AppModelsCoreErrorResponse",
            '422': "HTTPValidationError",
        }

        return self.api_client.call_api(
            '/api/v1/providers', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def google_auth_api_v1_auth_google_post(self, request_body : Dict[str, Any], **kwargs) -> object:  # noqa: E501
        """Google Auth  # noqa: E501

        Authenticate a user with Google OAuth token and set HTTP-only cookie  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.google_auth_api_v1_auth_google_post(request_body, async_req=True)
        >>> result = thread.get()

        :param request_body: (required)
        :type request_body: Dict[str, object]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the google_auth_api_v1_auth_google_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.google_auth_api_v1_auth_google_post_with_http_info(request_body, **kwargs)  # noqa: E501

    @validate_arguments
    def google_auth_api_v1_auth_google_post_with_http_info(self, request_body : Dict[str, Any], **kwargs) -> ApiResponse:  # noqa: E501
        """Google Auth  # noqa: E501

        Authenticate a user with Google OAuth token and set HTTP-only cookie  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.google_auth_api_v1_auth_google_post_with_http_info(request_body, async_req=True)
        >>> result = thread.get()

        :param request_body: (required)
        :type request_body: Dict[str, object]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'request_body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method google_auth_api_v1_auth_google_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['request_body'] is not None:
            _body_params = _params['request_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '500': "AppModelsCoreErrorResponse",
            '422': "HTTPValidationError",
        }

        return self.api_client.call_api(
            '/api/v1/auth/google', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def list_api_keys_api_v1_api_keys_get(self, auth_token : Optional[StrictStr] = None, **kwargs) -> List[ApiKeyInfo]:  # noqa: E501
        """List Api Keys  # noqa: E501

        List all API keys for the authenticated user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_api_keys_api_v1_api_keys_get(auth_token, async_req=True)
        >>> result = thread.get()

        :param auth_token:
        :type auth_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[ApiKeyInfo]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the list_api_keys_api_v1_api_keys_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.list_api_keys_api_v1_api_keys_get_with_http_info(auth_token, **kwargs)  # noqa: E501

    @validate_arguments
    def list_api_keys_api_v1_api_keys_get_with_http_info(self, auth_token : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List Api Keys  # noqa: E501

        List all API keys for the authenticated user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_api_keys_api_v1_api_keys_get_with_http_info(auth_token, async_req=True)
        >>> result = thread.get()

        :param auth_token:
        :type auth_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[ApiKeyInfo], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'auth_token'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_api_keys_api_v1_api_keys_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['OAuth2PasswordBearer']  # noqa: E501

        _response_types_map = {
            '200': "List[ApiKeyInfo]",
            '500': "AppModelsCoreErrorResponse",
            '422': "HTTPValidationError",
        }

        return self.api_client.call_api(
            '/api/v1/api-keys', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def logout_api_v1_auth_logout_post(self, **kwargs) -> object:  # noqa: E501
        """Logout  # noqa: E501

        Log out a user by clearing the auth cookie  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.logout_api_v1_auth_logout_post(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the logout_api_v1_auth_logout_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.logout_api_v1_auth_logout_post_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def logout_api_v1_auth_logout_post_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """Logout  # noqa: E501

        Log out a user by clearing the auth cookie  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.logout_api_v1_auth_logout_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method logout_api_v1_auth_logout_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '500': "AppModelsCoreErrorResponse",
        }

        return self.api_client.call_api(
            '/api/v1/auth/logout', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def providers_options_api_v1_providers_options(self, **kwargs) -> object:  # noqa: E501
        """Providers Options  # noqa: E501

        Handle preflight OPTIONS request for providers endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_options_api_v1_providers_options(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the providers_options_api_v1_providers_options_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.providers_options_api_v1_providers_options_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def providers_options_api_v1_providers_options_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """Providers Options  # noqa: E501

        Handle preflight OPTIONS request for providers endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.providers_options_api_v1_providers_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method providers_options_api_v1_providers_options" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '500': "AppModelsCoreErrorResponse",
        }

        return self.api_client.call_api(
            '/api/v1/providers', 'OPTIONS',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def root_get(self, **kwargs) -> object:  # noqa: E501
        """Root  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.root_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the root_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.root_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def root_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """Root  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.root_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method root_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '500': "AppModelsCoreErrorResponse",
        }

        return self.api_client.call_api(
            '/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def search_api_v1_search_get(self, query : Annotated[StrictStr, Field(..., description="Search query string")], language : Annotated[Optional[StrictStr], Field(description="ISO language code (e.g., 'en', 'fr')")] = None, country : Annotated[Optional[StrictStr], Field(description="Country code (e.g., 'us', 'gb')")] = None, max_results : Annotated[Optional[conint(strict=True, le=10, ge=1)], Field(description="Maximum number of results to return")] = None, summarize : Annotated[Optional[StrictBool], Field(description="Whether to generate a summary of results using LLM")] = None, provider : Annotated[Optional[StrictStr], Field(description="Search provider to use")] = None, topic : Annotated[Optional[StrictStr], Field(description="Search topic category")] = None, use_selenium : Annotated[Optional[StrictBool], Field(description="Whether to enhance DuckDuckGo results with Selenium (only applies to DuckDuckGo provider)")] = None, published_start_date : Annotated[Optional[date], Field(description="Start date for published content (YYYY-MM-DD)")] = None, published_end_date : Annotated[Optional[date], Field(description="End date for published content (YYYY-MM-DD)")] = None, crawl_start_date : Annotated[Optional[date], Field(description="Start date for crawled content (YYYY-MM-DD)")] = None, crawl_end_date : Annotated[Optional[date], Field(description="End date for crawled content (YYYY-MM-DD)")] = None, include_domains : Annotated[Optional[conlist(StrictStr)], Field(description="Domains to include in search results")] = None, exclude_domains : Annotated[Optional[conlist(StrictStr)], Field(description="Domains to exclude from search results")] = None, include_terms : Annotated[Optional[conlist(StrictStr)], Field(description="Terms that must be included in search results")] = None, exclude_terms : Annotated[Optional[conlist(StrictStr)], Field(description="Terms that must be excluded from search results")] = None, **kwargs) -> SearchResponse:  # noqa: E501
        """Search  # noqa: E501

        Search endpoint that returns formatted results from external search provider.  Args:     query: The search query string     language: Optional ISO language code (e.g., 'en', 'fr')     country: Optional country code (e.g., 'us', 'gb')     max_results: Maximum number of results to return (1-10)     summarize: Whether to generate a summary of results using LLM     provider: Search provider to use (google, bing, duckduckgo)     topic: Search topic category     use_selenium: Whether to enhance DuckDuckGo results with Selenium     published_start_date: Filter results published after this date     published_end_date: Filter results published before this date     crawl_start_date: Filter results crawled after this date     crawl_end_date: Filter results crawled before this date     include_domains: Filter results to only include these domains     exclude_domains: Filter results to exclude these domains     include_terms: Filter results to only include these terms     exclude_terms: Filter results to exclude these terms      Returns:     JSON response with formatted search results  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_api_v1_search_get(query, language, country, max_results, summarize, provider, topic, use_selenium, published_start_date, published_end_date, crawl_start_date, crawl_end_date, include_domains, exclude_domains, include_terms, exclude_terms, async_req=True)
        >>> result = thread.get()

        :param query: Search query string (required)
        :type query: str
        :param language: ISO language code (e.g., 'en', 'fr')
        :type language: str
        :param country: Country code (e.g., 'us', 'gb')
        :type country: str
        :param max_results: Maximum number of results to return
        :type max_results: int
        :param summarize: Whether to generate a summary of results using LLM
        :type summarize: bool
        :param provider: Search provider to use
        :type provider: str
        :param topic: Search topic category
        :type topic: str
        :param use_selenium: Whether to enhance DuckDuckGo results with Selenium (only applies to DuckDuckGo provider)
        :type use_selenium: bool
        :param published_start_date: Start date for published content (YYYY-MM-DD)
        :type published_start_date: date
        :param published_end_date: End date for published content (YYYY-MM-DD)
        :type published_end_date: date
        :param crawl_start_date: Start date for crawled content (YYYY-MM-DD)
        :type crawl_start_date: date
        :param crawl_end_date: End date for crawled content (YYYY-MM-DD)
        :type crawl_end_date: date
        :param include_domains: Domains to include in search results
        :type include_domains: List[str]
        :param exclude_domains: Domains to exclude from search results
        :type exclude_domains: List[str]
        :param include_terms: Terms that must be included in search results
        :type include_terms: List[str]
        :param exclude_terms: Terms that must be excluded from search results
        :type exclude_terms: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SearchResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the search_api_v1_search_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.search_api_v1_search_get_with_http_info(query, language, country, max_results, summarize, provider, topic, use_selenium, published_start_date, published_end_date, crawl_start_date, crawl_end_date, include_domains, exclude_domains, include_terms, exclude_terms, **kwargs)  # noqa: E501

    @validate_arguments
    def search_api_v1_search_get_with_http_info(self, query : Annotated[StrictStr, Field(..., description="Search query string")], language : Annotated[Optional[StrictStr], Field(description="ISO language code (e.g., 'en', 'fr')")] = None, country : Annotated[Optional[StrictStr], Field(description="Country code (e.g., 'us', 'gb')")] = None, max_results : Annotated[Optional[conint(strict=True, le=10, ge=1)], Field(description="Maximum number of results to return")] = None, summarize : Annotated[Optional[StrictBool], Field(description="Whether to generate a summary of results using LLM")] = None, provider : Annotated[Optional[StrictStr], Field(description="Search provider to use")] = None, topic : Annotated[Optional[StrictStr], Field(description="Search topic category")] = None, use_selenium : Annotated[Optional[StrictBool], Field(description="Whether to enhance DuckDuckGo results with Selenium (only applies to DuckDuckGo provider)")] = None, published_start_date : Annotated[Optional[date], Field(description="Start date for published content (YYYY-MM-DD)")] = None, published_end_date : Annotated[Optional[date], Field(description="End date for published content (YYYY-MM-DD)")] = None, crawl_start_date : Annotated[Optional[date], Field(description="Start date for crawled content (YYYY-MM-DD)")] = None, crawl_end_date : Annotated[Optional[date], Field(description="End date for crawled content (YYYY-MM-DD)")] = None, include_domains : Annotated[Optional[conlist(StrictStr)], Field(description="Domains to include in search results")] = None, exclude_domains : Annotated[Optional[conlist(StrictStr)], Field(description="Domains to exclude from search results")] = None, include_terms : Annotated[Optional[conlist(StrictStr)], Field(description="Terms that must be included in search results")] = None, exclude_terms : Annotated[Optional[conlist(StrictStr)], Field(description="Terms that must be excluded from search results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Search  # noqa: E501

        Search endpoint that returns formatted results from external search provider.  Args:     query: The search query string     language: Optional ISO language code (e.g., 'en', 'fr')     country: Optional country code (e.g., 'us', 'gb')     max_results: Maximum number of results to return (1-10)     summarize: Whether to generate a summary of results using LLM     provider: Search provider to use (google, bing, duckduckgo)     topic: Search topic category     use_selenium: Whether to enhance DuckDuckGo results with Selenium     published_start_date: Filter results published after this date     published_end_date: Filter results published before this date     crawl_start_date: Filter results crawled after this date     crawl_end_date: Filter results crawled before this date     include_domains: Filter results to only include these domains     exclude_domains: Filter results to exclude these domains     include_terms: Filter results to only include these terms     exclude_terms: Filter results to exclude these terms      Returns:     JSON response with formatted search results  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_api_v1_search_get_with_http_info(query, language, country, max_results, summarize, provider, topic, use_selenium, published_start_date, published_end_date, crawl_start_date, crawl_end_date, include_domains, exclude_domains, include_terms, exclude_terms, async_req=True)
        >>> result = thread.get()

        :param query: Search query string (required)
        :type query: str
        :param language: ISO language code (e.g., 'en', 'fr')
        :type language: str
        :param country: Country code (e.g., 'us', 'gb')
        :type country: str
        :param max_results: Maximum number of results to return
        :type max_results: int
        :param summarize: Whether to generate a summary of results using LLM
        :type summarize: bool
        :param provider: Search provider to use
        :type provider: str
        :param topic: Search topic category
        :type topic: str
        :param use_selenium: Whether to enhance DuckDuckGo results with Selenium (only applies to DuckDuckGo provider)
        :type use_selenium: bool
        :param published_start_date: Start date for published content (YYYY-MM-DD)
        :type published_start_date: date
        :param published_end_date: End date for published content (YYYY-MM-DD)
        :type published_end_date: date
        :param crawl_start_date: Start date for crawled content (YYYY-MM-DD)
        :type crawl_start_date: date
        :param crawl_end_date: End date for crawled content (YYYY-MM-DD)
        :type crawl_end_date: date
        :param include_domains: Domains to include in search results
        :type include_domains: List[str]
        :param exclude_domains: Domains to exclude from search results
        :type exclude_domains: List[str]
        :param include_terms: Terms that must be included in search results
        :type include_terms: List[str]
        :param exclude_terms: Terms that must be excluded from search results
        :type exclude_terms: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SearchResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'query',
            'language',
            'country',
            'max_results',
            'summarize',
            'provider',
            'topic',
            'use_selenium',
            'published_start_date',
            'published_end_date',
            'crawl_start_date',
            'crawl_end_date',
            'include_domains',
            'exclude_domains',
            'include_terms',
            'exclude_terms'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_api_v1_search_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('query') is not None:  # noqa: E501
            _query_params.append(('query', _params['query']))

        if _params.get('language') is not None:  # noqa: E501
            _query_params.append(('language', _params['language']))

        if _params.get('country') is not None:  # noqa: E501
            _query_params.append(('country', _params['country']))

        if _params.get('max_results') is not None:  # noqa: E501
            _query_params.append(('max_results', _params['max_results']))

        if _params.get('summarize') is not None:  # noqa: E501
            _query_params.append(('summarize', _params['summarize']))

        if _params.get('provider') is not None:  # noqa: E501
            _query_params.append(('provider', _params['provider']))

        if _params.get('topic') is not None:  # noqa: E501
            _query_params.append(('topic', _params['topic']))

        if _params.get('use_selenium') is not None:  # noqa: E501
            _query_params.append(('use_selenium', _params['use_selenium']))

        if _params.get('published_start_date') is not None:  # noqa: E501
            if isinstance(_params['published_start_date'], date):
                _query_params.append(('published_start_date', _params['published_start_date'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('published_start_date', _params['published_start_date']))

        if _params.get('published_end_date') is not None:  # noqa: E501
            if isinstance(_params['published_end_date'], date):
                _query_params.append(('published_end_date', _params['published_end_date'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('published_end_date', _params['published_end_date']))

        if _params.get('crawl_start_date') is not None:  # noqa: E501
            if isinstance(_params['crawl_start_date'], date):
                _query_params.append(('crawl_start_date', _params['crawl_start_date'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('crawl_start_date', _params['crawl_start_date']))

        if _params.get('crawl_end_date') is not None:  # noqa: E501
            if isinstance(_params['crawl_end_date'], date):
                _query_params.append(('crawl_end_date', _params['crawl_end_date'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('crawl_end_date', _params['crawl_end_date']))

        if _params.get('include_domains') is not None:  # noqa: E501
            _query_params.append(('include_domains', _params['include_domains']))
            _collection_formats['include_domains'] = 'multi'

        if _params.get('exclude_domains') is not None:  # noqa: E501
            _query_params.append(('exclude_domains', _params['exclude_domains']))
            _collection_formats['exclude_domains'] = 'multi'

        if _params.get('include_terms') is not None:  # noqa: E501
            _query_params.append(('include_terms', _params['include_terms']))
            _collection_formats['include_terms'] = 'multi'

        if _params.get('exclude_terms') is not None:  # noqa: E501
            _query_params.append(('exclude_terms', _params['exclude_terms']))
            _collection_formats['exclude_terms'] = 'multi'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SearchResponse",
            '500': "AppSchemasSearchErrorResponse",
            '422': "HTTPValidationError",
        }

        return self.api_client.call_api(
            '/api/v1/search', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_api_key_status_endpoint_api_v1_api_keys_key_id_status_put(self, key_id : StrictStr, status : ApiKeyStatus, auth_token : Optional[StrictStr] = None, **kwargs) -> object:  # noqa: E501
        """Update Api Key Status Endpoint  # noqa: E501

        Update the status of an API key (activate, disable, revoke)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_api_key_status_endpoint_api_v1_api_keys_key_id_status_put(key_id, status, auth_token, async_req=True)
        >>> result = thread.get()

        :param key_id: (required)
        :type key_id: str
        :param status: (required)
        :type status: ApiKeyStatus
        :param auth_token:
        :type auth_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the update_api_key_status_endpoint_api_v1_api_keys_key_id_status_put_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.update_api_key_status_endpoint_api_v1_api_keys_key_id_status_put_with_http_info(key_id, status, auth_token, **kwargs)  # noqa: E501

    @validate_arguments
    def update_api_key_status_endpoint_api_v1_api_keys_key_id_status_put_with_http_info(self, key_id : StrictStr, status : ApiKeyStatus, auth_token : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Update Api Key Status Endpoint  # noqa: E501

        Update the status of an API key (activate, disable, revoke)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_api_key_status_endpoint_api_v1_api_keys_key_id_status_put_with_http_info(key_id, status, auth_token, async_req=True)
        >>> result = thread.get()

        :param key_id: (required)
        :type key_id: str
        :param status: (required)
        :type status: ApiKeyStatus
        :param auth_token:
        :type auth_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'key_id',
            'status',
            'auth_token'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_api_key_status_endpoint_api_v1_api_keys_key_id_status_put" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['key_id'] is not None:
            _path_params['key_id'] = _params['key_id']


        # process the query parameters
        _query_params = []
        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status'].value))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['OAuth2PasswordBearer']  # noqa: E501

        _response_types_map = {
            '200': "object",
            '500': "AppModelsCoreErrorResponse",
            '422': "HTTPValidationError",
        }

        return self.api_client.call_api(
            '/api/v1/api-keys/{key_id}/status', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
